package model;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;

public class ElgamalModel {

    private static final SecureRandom rnd = new SecureRandom();
    private static final int CERTAINTY = 100;

    public static BigInteger hashToBigInteger(String message, BigInteger q) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hash = md.digest(message.getBytes("UTF-8"));
            BigInteger fullHash = new BigInteger(1, hash);
            
            BigInteger m = fullHash.mod(q.subtract(BigInteger.ONE)).add(BigInteger.ONE);
            return m; // m ∈ [1, q-2]
        } catch (Exception e) {
            throw new RuntimeException("Lỗi băm thông điệp", e);
        }
    }

    public static ElgamalKey generateKeyPair(int bitLength) {
        BigInteger q = BigInteger.probablePrime(bitLength, rnd);
        BigInteger a = findPrimitiveRoot(q);
        BigInteger x = new BigInteger(q.bitLength() - 1, rnd)
                .mod(q.subtract(BigInteger.TWO))
                .add(BigInteger.ONE);
        BigInteger y = a.modPow(x, q);
        return new ElgamalKey(q, a, y, x);
    }

    public static ElgamalKey createFromValues(BigInteger q, BigInteger a, BigInteger x) {
        if (!q.isProbablePrime(CERTAINTY))
            throw new IllegalArgumentException("q phải là số nguyên tố");
        if (!isPrimitiveRoot(a, q))
            throw new IllegalArgumentException("α phải là căn nguyên thủy mod q");
        if (x.compareTo(BigInteger.ONE) < 0 || x.compareTo(q.subtract(BigInteger.TWO)) > 0)
            throw new IllegalArgumentException("x phải thuộc [1, q-2]");
        BigInteger y = a.modPow(x, q);
        return new ElgamalKey(q, a, y, x);
    }

    public static class FullSignature {
        private final BigInteger r, s, k;
        public FullSignature(BigInteger r, BigInteger s, BigInteger k) {
            this.r = r; this.s = s; this.k = k;
        }
        public BigInteger getR() { return r; }
        public BigInteger getS() { return s; }
        public BigInteger getK() { return k; }
        @Override
        public String toString() { return r + "," + s + "," + k; }
    }

    public static FullSignature signWithK(String message, ElgamalKey keyPair, BigInteger userK) {
        BigInteger q = keyPair.getQ();
        BigInteger a = keyPair.getA();
        BigInteger x = keyPair.getX();

        // HASH ĐÚNG CÁCH
        BigInteger m = hashToBigInteger(message, q);

        BigInteger k = userK;
        boolean autoK = (k == null || k.signum() <= 0);

        do {
            if (autoK) {
                do {
                    k = new BigInteger(q.bitLength(), rnd)
                            .mod(q.subtract(BigInteger.TWO))
                            .add(BigInteger.ONE);
                } while (k.gcd(q.subtract(BigInteger.ONE)).compareTo(BigInteger.ONE) != 0);
            } else {
                if (k.compareTo(BigInteger.ONE) < 0 || k.compareTo(q.subtract(BigInteger.TWO)) > 0)
                    throw new IllegalArgumentException("k phải thuộc [1, q-2]");
                if (k.gcd(q.subtract(BigInteger.ONE)).compareTo(BigInteger.ONE) != 0)
                    throw new IllegalArgumentException("gcd(k, q-1) phải = 1");
            }

            BigInteger r = a.modPow(k, q);

            BigInteger xr = x.multiply(r).mod(q.subtract(BigInteger.ONE));
            BigInteger diff = m.subtract(xr);
            if (diff.signum() < 0) diff = diff.add(q.subtract(BigInteger.ONE));

            BigInteger kInv = k.modInverse(q.subtract(BigInteger.ONE));
            BigInteger s = kInv.multiply(diff).mod(q.subtract(BigInteger.ONE));

            if (s.signum() != 0) {
                return new FullSignature(r, s, k);
            }
        } while (autoK);

        throw new RuntimeException("Không thể ký với k này (s = 0)");
    }

    /**
     * XÁC MINH CHẮC CHẮN AN TOÀN – CÓ KIỂM TRA r, s TRONG PHẠM VI
     */
    public static boolean verify(String message, BigInteger r, BigInteger s, ElgamalKey publicKey) {
        BigInteger q = publicKey.getQ();
        BigInteger a = publicKey.getA();
        BigInteger y = publicKey.getY();

        // BẮT BUỘC KIỂM TRA PHẠM VI – KHÔNG CÓ CÁI NÀY LÀ CHẾT!
        if (r == null || s == null) return false;
        if (r.compareTo(BigInteger.ONE) < 0 || r.compareTo(q.subtract(BigInteger.ONE)) >= 0) return false;
        if (s.compareTo(BigInteger.ONE) < 0 || s.compareTo(q.subtract(BigInteger.ONE)) >= 0) return false;

        // DÙNG CÙNG HÀM HASH ĐÃ SỬA
        BigInteger m = hashToBigInteger(message, q);

        BigInteger v1 = a.modPow(m, q);
        BigInteger v2 = y.modPow(r, q).multiply(r.modPow(s, q)).mod(q);

        return v1.equals(v2);
    }

    // === CÁC HÀM HỖ TRỢ KHÔNG ĐỔI ===
    private static boolean isPrimitiveRoot(BigInteger g, BigInteger q) {
        BigInteger p = q.subtract(BigInteger.ONE);
        List<BigInteger> factors = primeFactors(p);
        for (BigInteger f : factors) {
            if (g.modPow(p.divide(f), q).equals(BigInteger.ONE)) return false;
        }
        return true;
    }

    public static BigInteger findPrimitiveRoot(BigInteger q) {
        BigInteger[] candidates = {BigInteger.valueOf(2), BigInteger.valueOf(3), BigInteger.valueOf(5),
                BigInteger.valueOf(6), BigInteger.valueOf(7), BigInteger.valueOf(10)};
        for (BigInteger g : candidates) {
            if (g.compareTo(q) < 0 && isPrimitiveRoot(g, q)) return g;
        }
        for (int i = 0; i < 1000; i++) {
            BigInteger g = new BigInteger(q.bitLength(), rnd).mod(q.subtract(BigInteger.ONE)).add(BigInteger.ONE);
            if (isPrimitiveRoot(g, q)) return g;
        }
        throw new RuntimeException("Không tìm được căn nguyên thủy");
    }

    private static List<BigInteger> primeFactors(BigInteger n) {
        List<BigInteger> factors = new ArrayList<>();
        BigInteger num = n;
        while (num.mod(BigInteger.TWO).equals(BigInteger.ZERO)) {
            factors.add(BigInteger.TWO);
            num = num.divide(BigInteger.TWO);
        }
        for (BigInteger i = BigInteger.valueOf(3); i.multiply(i).compareTo(num) <= 0; i = i.add(BigInteger.TWO)) {
            while (num.mod(i).equals(BigInteger.ZERO)) {
                factors.add(i);
                num = num.divide(i);
            }
        }
        if (num.compareTo(BigInteger.ONE) > 0) factors.add(num);
        return new ArrayList<>(new java.util.HashSet<>(factors));
    }
}