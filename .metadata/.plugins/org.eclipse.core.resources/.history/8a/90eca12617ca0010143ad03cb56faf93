package model;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

public class ElgamalModel {

    private static final SecureRandom rnd = new SecureRandom();
    private static final int CERTAINTY = 100;

    /* ====================== BĂM THÔNG ĐIỆP ====================== */
    public static BigInteger hashToBigInteger(String message, BigInteger q) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hash = md.digest(message.getBytes("UTF-8"));
            return new BigInteger(1, hash).mod(q); // luôn dương
        } catch (Exception e) {
            throw new RuntimeException("Lỗi băm SHA-256: " + e.getMessage());
        }
    }

    /* ====================== TẠO KHÓA ====================== */
    public static ElgamalKey generateKeyPair(int bitLength) {
        BigInteger q = BigInteger.probablePrime(bitLength, rnd);
        BigInteger a = findPrimitiveRoot(q);
        BigInteger x = new BigInteger(q.bitLength() - 1, rnd)
                .mod(q.subtract(BigInteger.TWO))
                .add(BigInteger.ONE);               // 1 ≤ x ≤ q-2
        BigInteger y = a.modPow(x, q);
        return new ElgamalKey(q, a, y, x);
    }

    public static ElgamalKey createFromValues(BigInteger q, BigInteger a, BigInteger x) {
        if (!q.isProbablePrime(CERTAINTY))
            throw new IllegalArgumentException("q phải là số nguyên tố");
        if (!isPrimitiveRoot(a, q))
            throw new IllegalArgumentException("a phải là căn nguyên thủy của q");
        if (x.compareTo(BigInteger.ONE) < 0 || x.compareTo(q.subtract(BigInteger.TWO)) > 0)
            throw new IllegalArgumentException("x phải thuộc [1, q-2]");
        BigInteger y = a.modPow(x, q);
        return new ElgamalKey(q, a, y, x);
    }

    /* ====================== KÝ VĂN BẢN – CHUẨN ELGAMAL ====================== */
    public static Signature sign(String message, ElgamalKey keyPair) {
        if (keyPair == null || keyPair.getX() == null)
            throw new IllegalStateException("Chưa có khóa bí mật để ký!");
        if (message == null || message.trim().isEmpty())
            throw new IllegalArgumentException("Thông điệp không được rỗng!");

        BigInteger q = keyPair.getQ();
        BigInteger a = keyPair.getA();
        BigInteger x = keyPair.getX();

        BigInteger m = hashToBigInteger(message, q);
        BigInteger k, r, s, kInv;

        do {
            // Chọn k ngẫu nhiên: 1 < k < q-1 và gcd(k, q-1) = 1
            do {
                k = new BigInteger(q.bitLength() - 1, rnd)
                        .mod(q.subtract(BigInteger.ONE))
                        .add(BigInteger.ONE);
            } while (k.gcd(q.subtract(BigInteger.ONE)).compareTo(BigInteger.ONE) != 0);

            r = a.modPow(k, q); // r = a^k mod q

            // s = k⁻¹ * (H(m) - x*r) mod (q-1)   ←←← CÔNG THỨC ĐÚNG CỦA ELGAMAL
            kInv = k.modInverse(q.subtract(BigInteger.ONE));
            BigInteger temp = m.subtract(x.multiply(r).mod(q));
            if (temp.signum() < 0) {
                temp = temp.add(q.subtract(BigInteger.ONE));
            }
            s = kInv.multiply(temp).mod(q.subtract(BigInteger.ONE));

        } while (s.signum() == 0); // s ≠ 0

        return new Signature(r, s);
    }

    /* ====================== XÁC MINH CHỮ KÝ – CHUẨN ELGAMAL ====================== */
    public static boolean verify(String message, Signature signature, ElgamalKey publicKey) {
        if (publicKey == null)
            throw new IllegalStateException("Chưa có khóa công khai!");
        if (message == null || message.trim().isEmpty())
            throw new IllegalArgumentException("Thông điệp rỗng!");
        if (signature == null)
            throw new IllegalArgumentException("Chữ ký null!");

        BigInteger q = publicKey.getQ();
        BigInteger a = publicKey.getA();
        BigInteger y = publicKey.getY();
        BigInteger r = signature.getR();
        BigInteger s = signature.getS();

        // Kiểm tra r, s hợp lệ
        if (r.signum() <= 0 || r.compareTo(q) >= 0) return false;
        if (s.signum() <= 0 || s.compareTo(q.subtract(BigInteger.ONE)) >= 0) return false;

        BigInteger m = hashToBigInteger(message, q);

        BigInteger left  = a.modPow(m, q);                                          // a^H(m) mod q
        BigInteger right = y.modPow(r, q).multiply(r.modPow(s, q)).mod(q);         // y^r * r^s mod q

        return left.equals(right);
    }

    /* ====================== HỖ TRỢ: TÌM CĂN NGUYÊN THỦY ====================== */
    private static boolean isPrimitiveRoot(BigInteger g, BigInteger q) {
        BigInteger phi = q.subtract(BigInteger.ONE);
        List<BigInteger> factors = primeFactors(phi);
        for (BigInteger f : factors) {
            if (g.modPow(phi.divide(f), q).equals(BigInteger.ONE)) {
                return false;
            }
        }
        return true;
    }

    public static BigInteger findPrimitiveRoot(BigInteger q) {
        BigInteger[] candidates = { BigInteger.valueOf(2), BigInteger.valueOf(3), BigInteger.valueOf(5),
                BigInteger.valueOf(6), BigInteger.valueOf(7), BigInteger.valueOf(10), BigInteger.valueOf(11) };
        for (BigInteger g : candidates) {
            if (g.compareTo(q) < 0 && isPrimitiveRoot(g, q)) return g;
        }
        // Fallback ngẫu nhiên
        for (int i = 0; i < 1000; i++) {
            BigInteger g = new BigInteger(q.bitLength(), rnd).mod(q.subtract(BigInteger.ONE)).add(BigInteger.TWO);
            if (isPrimitiveRoot(g, q)) return g;
        }
        throw new RuntimeException("Không tìm được căn nguyên thủy cho q = " + q);
    }

    private static List<BigInteger> primeFactors(BigInteger n) {
        List<BigInteger> factors = new ArrayList<>();
        BigInteger num = n;
        while (num.mod(BigInteger.TWO).equals(BigInteger.ZERO)) {
            factors.add(BigInteger.TWO);
            num = num.divide(BigInteger.TWO);
        }
        BigInteger i = BigInteger.valueOf(3);
        while (i.multiply(i).compareTo(num) <= 0) {
            while (num.mod(i).equals(BigInteger.ZERO)) {
                factors.add(i);
                num = num.divide(i);
            }
            i = i.add(BigInteger.TWO);
        }
        if (num.compareTo(BigInteger.ONE) > 0) factors.add(num);
        return new ArrayList<>(new java.util.HashSet<>(factors)); // chỉ lấy thừa số riêng biệt
    }

    /* ====================== HỖ TRỢ: CHUYỂN ĐỔI BASE64 ====================== */
    public static String signatureToBase64(Signature sig) {
        String r64 = Base64.getEncoder().encodeToString(sig.getR().toByteArray());
        String s64 = Base64.getEncoder().encodeToString(sig.getS().toByteArray());
        return r64 + "," + s64;
    }

    public static Signature signatureFromBase64(String base64) {
        String[] parts = base64.split(",");
        if (parts.length != 2) throw new IllegalArgumentException("Chữ ký Base64 sai định dạng");
        BigInteger r = new BigInteger(1, Base64.getDecoder().decode(parts[0].trim()));
        BigInteger s = new BigInteger(1, Base64.getDecoder().decode(parts[1].trim()));
        return new Signature(r, s);
    }
}